`casemate-check` takes a log file and performs an offline check for protcol violations.


=== Usage

Usage: `casemate-check FILE [OPTIONS]`

General options:

* `-h | --help` prints help text.

* `-q` makes the tool quiet, with no output.

* `--color`   enabl ANSI escape color codes

* `-a | --no-color`   force ascii-only, no ANSI escape color codes


Model options:

* `-R | --racy`   do not check locks/synchronisation are respected

* `-C | --dry-run`    do not run checks


Output options:

* `-c`              condensed trace format

* `-p | --print`      print state out at each step

*  `-t | --trace`      print trace record for each step

*  `-T | --no-trace`   do not print trace record for each step

* `-d | --diff`       show diffs of state

* `-U | --all`        show all (including unclean) locations in states/diffs

* `-W<addr>`        watch this address

Other:

* `-D | --debug`      debug mode

=== Example usage

The following is a log file generated by the `good_bbm` example,
and can be generated by running the associated code (see the examples README).

----
$ cat example.log
(mem-init (id 0) (tid 0) (address 0xaaaadce53000) (size 0x1000) (src "examples/tests/good_bbm.c:25"))
(mem-init (id 1) (tid 0) (address 0xaaaadce54000) (size 0x1000) (src "examples/tests/good_bbm.c:26"))
(mem-init (id 2) (tid 0) (address 0xaaaadce55000) (size 0x1000) (src "examples/tests/good_bbm.c:27"))
(hint (id 3) (tid 0) (kind set_root_lock) (location 0xaaaadce53000) (value 0xaaaadce56000) (src "examples/tests/good_bbm.c:28"))
(hint (id 4) (tid 0) (kind set_owner_root) (location 0xaaaadce54000) (value 0xaaaadce53000) (src "examples/tests/good_bbm.c:29"))
(hint (id 5) (tid 0) (kind set_owner_root) (location 0xaaaadce55000) (value 0xaaaadce53000) (src "examples/tests/good_bbm.c:30"))
(mem-write (id 6) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0xaaaadce54003) (src "examples/tests/good_bbm.c:33"))
(sysreg-write (id 7) (tid 0) (sysreg vttbr_el2) (value 0xaaaadce53000) (src "examples/tests/good_bbm.c:36"))
(lock (id 8) (tid 0) (address 0xaaaadce56000) (src "examples/tests/good_bbm.c:38"))
(mem-write (id 9) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0x0) (src "examples/tests/good_bbm.c:39"))
(barrier (id 10) (tid 0) dsb (kind ish) (src "examples/tests/good_bbm.c:40"))
(tlbi (id 11) (tid 0) ipas2e1is (addr 0x0) (level 0x3) (src "examples/tests/good_bbm.c:41"))
(barrier (id 12) (tid 0) dsb (kind ish) (src "examples/tests/good_bbm.c:42"))
(tlbi (id 13) (tid 0) vmalle1is (src "examples/tests/good_bbm.c:43"))
(barrier (id 14) (tid 0) dsb (kind ish) (src "examples/tests/good_bbm.c:44"))
(mem-write (id 15) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0xaaaadce55003) (src "examples/tests/good_bbm.c:45"))
(unlock (id 16) (tid 0) (address 0xaaaadce56000) (src "examples/tests/good_bbm.c:46"))
----

`casemate-check` can be used to check this log for violations:

----
$ ./casemate-check examples/expected/good_bbm.log 
[...]
casemate-check: log checked successfully.
----

==== Checking racy executions

Here is a log from a racy execution

----
$ cat bad_race.log
(mem-init (id 0) (tid 0) (address 0xaaaad7824000) (size 0x1000) (src "examples/tests/bad_race.c:34"))
(hint (id 1) (tid 0) (kind set_root_lock) (location 0xaaaad7824000) (value 0xaaaad7825000) (src "examples/tests/bad_race.c:35"))
(sysreg-write (id 2) (tid 0) (sysreg vttbr_el2) (value 0xaaaad7824000) (src "examples/tests/bad_race.c:38"))
(mem-write (id 4) (tid 1) (mem-order release) (address 0xaaaad7824008) (value 0x1) (src "examples/tests/bad_race.c:24"))
(mem-write (id 3) (tid 2) (mem-order release) (address 0xaaaad7824008) (value 0x1) (src "examples/tests/bad_race.c:24"))
----

Note the two concurrently writes from threads 1 and 2 to the same location without sufficient locking.
Running this with `casemate-check` reports an error, that the concurrent accesses are not locked.

One can disable race detection with the `-R` flag. Full break-before-make checking is done on the trace,
but does not guarantee that there are no data races on the locations.

----
$ ./casemate-check bad_race.log
[...]
! must write to pte while holding owner lock

$ ./casemate-check -R bad_race.log
[...]
casemate-check: log checked successfully.
----


==== Printing model state

By default, `casemate-check` prints out the trace as it goes.
More information can be seen by supplying the `-p` or `-d` options.

`-p` prints out the Casemate model state at each step.
By default, this is only for the _unclean_ locations.
All locations can be seen by printing unclean (`-pU`).

More often it is more useful to show just the _change_ to the state on each step.
This can be achieved by passing `-d` to produce _diffs_.

----
$ ./casemate-check ./examples/expected/good_bbm.log -d
(mem-init (id 0) (tid 0) (address 0xaaaadce53000) (size 0x1000) (src ""examples/tests/good_bbm.c:25":0"))
<identical>
(mem-init (id 1) (tid 0) (address 0xaaaadce54000) (size 0x1000) (src ""examples/tests/good_bbm.c:26":0"))
<identical>
(mem-init (id 2) (tid 0) (address 0xaaaadce55000) (size 0x1000) (src ""examples/tests/good_bbm.c:27":0"))
<identical>
(hint (id 3) (tid 0) (kind set_root_lock) (location 0xaaaadce53000) (value 0xaaaadce56000) (src ""examples/tests/good_bbm.c:28":0"))
<identical>
(hint (id 4) (tid 0) (kind set_owner_root) (location 0xaaaadce54000) (value 0xaaaadce53000) (src ""examples/tests/good_bbm.c:29":0"))
<identical>
(hint (id 5) (tid 0) (kind set_owner_root) (location 0xaaaadce55000) (value 0xaaaadce53000) (src ""examples/tests/good_bbm.c:30":0"))
<identical>
(mem-write (id 6) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0xaaaadce54003) (src ""examples/tests/good_bbm.c:33":0"))
<identical>
(sysreg-write (id 7) (tid 0) (sysreg vttbr_el2) (value 0xaaaadce53000) (src ""examples/tests/good_bbm.c:36":0"))
<identical>
(lock (id 8) (tid 0) (address 0xaaaadce56000) (src ""examples/tests/good_bbm.c:38":0"))
<identical>
(mem-write (id 9) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0x0) (src ""examples/tests/good_bbm.c:39":0"))
mem:
    -*[  0xaaaadce53000]=    aaaadce54003 (pte_st:V       root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:IU n  0 root:  0xaaaadce53000, range:               0-      8000000000)
(barrier (id 10) (tid 0) dsb (kind ish) (src ""examples/tests/good_bbm.c:40":0"))
mem:
    -*[  0xaaaadce53000]=               0 (pte_st:IU n  0 root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:IU d  0 root:  0xaaaadce53000, range:               0-      8000000000)
(tlbi (id 11) (tid 0) ipas2e1is (addr 0x0) (level 0x0) (src ""examples/tests/good_bbm.c:41":0"))
mem:
    -*[  0xaaaadce53000]=               0 (pte_st:IU d  0 root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:IU ti 0 root:  0xaaaadce53000, range:               0-      8000000000)
(barrier (id 12) (tid 0) dsb (kind ish) (src ""examples/tests/good_bbm.c:42":0"))
mem:
    -*[  0xaaaadce53000]=               0 (pte_st:IU ti 0 root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:IU td 0 root:  0xaaaadce53000, range:               0-      8000000000)
(tlbi (id 13) (tid 0) vmalle1is (src ""examples/tests/good_bbm.c:43":0"))
mem:
    -*[  0xaaaadce53000]=               0 (pte_st:IU td 0 root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:IU ta 0 root:  0xaaaadce53000, range:               0-      8000000000)
(barrier (id 14) (tid 0) dsb (kind ish) (src ""examples/tests/good_bbm.c:44":0"))
mem:
    -*[  0xaaaadce53000]=               0 (pte_st:IU ta 0 root:  0xaaaadce53000, range:               0-      8000000000)
    +*[  0xaaaadce53000]=               0 (pte_st:I     0 root:  0xaaaadce53000, range:               0-      8000000000)
(mem-write (id 15) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0xaaaadce55003) (src ""examples/tests/good_bbm.c:45":0"))
<identical>
(unlock (id 16) (tid 0) (address 0xaaaadce56000) (src ""examples/tests/good_bbm.c:46":0"))
<identical>
casemate-check: log checked successfully.
----

We can see that the first write to `0xaaaadce53000` transitions that location's state
from valid (`V`) to invalid-but-unclean (`IU`) with no synchronisation (`n`).
The following `DSB` on the same thread transitions the state to invalid-unclean but with DSB synchronisation (`IU d`).
The subsequent TLBI-IPA transitions the per-thread state to invalid-unclean but with TLB maintenance but no synchronisation (`IU ti`).
Then the `DSB` moves the per-thread state to invalid-unclean, with synchronised TLB maintenance (`IU td`),
before the final TLBI-ALL puts the state in the `IU ta` state representing the fully-cleaned (but not yet globally synchronised) TLB maintenance.
The final `DSB` then transitions the global state from invalid-unclean with some thread-local state to a new global invalid-clean state (`I`).

===== State format

The format of locations printed by `-p` and `-d` are compact representations of the state machine.

Each location is printed as
----
<UNCLEAN MARK ?>[<ADDRESS>]=<VALUE> (pte_st:<STATE> root: <PAGETABLE ROOT ADDRESS> range: <IA RANGE>)
----

Where:

* `<UNCLEAN MARK>` is either empty or a single `*` if the location is unclean.

* `<STATE>` is the top-level automata state, one of:
** `V` for valid;
**`IU <ukind> <old value>` for invalid-but-unclean values, where `ukind` is the per-thread automata state (see below);
** or `I <old value>` for invalid-and-clean locations.

* `<IA RANGE>` is the range of input addresses (virtual, or intermediate-physical) that this page table entry maps.

* `<ukind>` is the per-thread pte state, for the thread that invalidated the entry, and is one of:
** `n` for no synchronisation;
** `d` for a single `DSB` without any TLB maintenance;
** `ti` for having done a TLBI-by-IPA for this pte's range, but not yet synchronised;
** `td` for the TLBI-by-IPA which has been synchronised (by a `DSB`);
** `ta` for having been TLBI-by-VA or TLBI-ALL cleaned.

****
Note that the per-thread pte states do not include the trailing `DSB` as that transitions the global automata state not the per-thread one.
****

==== Watching locations

On a large trace, even simple diffs may be too noisy.
It is possible to tell the Casemate model to 'watch' only particular locations,
and print out only transitions which touch them.

For example, watching location `0xaaaadce55000` (the new child page) in the above trace
we get prints only for two transitions:
the first initialises it;
the other is not a transition to that location but to its parent which affects the state of the child,
so is also counted in the watch.
In this case the global pte state of that particular location is unchanged, so the diffs are empty.

----
./casemate-check ./examples/expected/good_bbm.log -d -W0xaaaadce55000
(mem-init (id 2) (tid 0) (address 0xaaaadce55000) (size 0x1000) (src ""examples/tests/good_bbm.c:27":0"))
<identical>
(mem-write (id 15) (tid 0) (mem-order plain) (address 0xaaaadce53000) (value 0xaaaadce55003) (src ""examples/tests/good_bbm.c:45":0"))
<identical>
casemate-check: log checked successfully.
----

****
This only affects the printing, the full model is simulated and checks still performed for all locations.
****
